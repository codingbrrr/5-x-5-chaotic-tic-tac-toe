<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>5×5 Tic-Tac-Toe — Single File (Easy / Medium / Hard)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    :root{
      --bg:#f4f6f8;
      --panel:#ffffff;
      --accent:#111827;
      --x-color:#e53935;
      --o-color:#1d4ed8;
    }
    *{box-sizing:border-box;font-family:Inter, ui-sans-serif, system-ui, -apple-system, Arial, sans-serif}
    body{margin:0;background:var(--bg);color:var(--accent);display:flex;min-height:100vh;align-items:flex-start;justify-content:center;padding:24px}
    .app{width:100%;max-width:1100px}
    header{display:flex;align-items:center;justify-content:space-between;margin-bottom:16px}
    h1{font-size:20px;margin:0}
    nav button{margin-left:8px;padding:8px 10px;border-radius:8px;border:1px solid rgba(0,0,0,0.06);background:#fff;cursor:pointer}
    .page{display:none}
    .page.active{display:block}
    .panel{background:var(--panel);padding:16px;border-radius:12px;box-shadow:0 6px 20px rgba(15,23,42,0.06)}
    .board{display:grid;grid-template-columns:repeat(5,64px);grid-template-rows:repeat(5,64px);gap:8px;margin:12px 0}
    .cell{width:64px;height:64px;border-radius:8px;background:#fff;border:1px solid rgba(0,0,0,0.06);display:flex;align-items:center;justify-content:center;font-weight:700;font-size:28px;cursor:pointer;user-select:none}
    .cell.disabled{cursor:not-allowed;opacity:0.6}
    .status{min-width:260px}
    .timer{font-size:28px;font-weight:700}
    .current-symbol{margin-top:8px;font-size:16px}
    .controls{margin-top:10px}
    .instructions{margin-bottom:12px;padding:8px;border-radius:8px;background:linear-gradient(180deg,rgba(0,0,0,0.02),transparent)}
    .chat{margin-top:12px;border-radius:8px;padding:8px;background:#fafafa;border:1px solid rgba(0,0,0,0.04)}
    .chat-log{height:160px;overflow:auto;padding:6px;background:#fff;border-radius:6px;border:1px solid rgba(0,0,0,0.04)}
    .chat-input{display:flex;margin-top:8px}
    .chat-input input{flex:1;padding:8px;border-radius:6px;border:1px solid rgba(0,0,0,0.08)}
    .chat-input button{margin-left:8px;padding:8px 12px;border-radius:6px}
    .hint{outline:3px solid rgba(16,185,129,0.18);transform:scale(1.02)}
    footer{margin-top:18px;text-align:center;color:rgba(0,0,0,0.45)}
    @media (max-width:900px){.board{grid-template-columns:repeat(5,52px);grid-template-rows:repeat(5,52px)}.cell{width:52px;height:52px;font-size:22px}}
  </style>
</head>
<body>
  <div class="app">
    <header>
      <h1>5×5 Tic-Tac-Toe — 4 in a row</h1>
      <nav>
        <button onclick="go('home')">Home</button>
        <button onclick="go('easy')">Easy</button>
        <button onclick="go('medium')">Medium</button>
        <button onclick="go('hard')">Hard</button>
      </nav>
    </header>

    <main>
      <!-- HOME -->
      <section id="home" class="page active panel">
        <h2>Home & Tutorial</h2>
        <div class="instructions">
          <strong>Rules (short):</strong> 5×5 board. Win = 4 in a row (horizontal, vertical, diagonal). There are no permanent X/O players:
          you start as <strong>O</strong>. After your move and the computer's reply, your symbol flips (O ↔ X). If you run out of time on your turn, you forfeit and the computer wins.
        </div>

        <div style="display:flex;gap:16px;align-items:flex-start;">
          <div style="flex:1">
            <h3>Tutorial (interactive)</h3>
            <div id="tutorial-board" class="board"></div>
            <div id="tutorial-explain" style="margin-top:8px;padding:8px;background:#fff;border-radius:8px;border:1px solid rgba(0,0,0,0.04)">
              Click any empty cell to place <strong>O</strong>. After your click the computer will respond; the explanation will appear here. If a 4-in-a-row appears the tutorial announces the winner and advises reset.
            </div>
            <div style="margin-top:8px;">
              <button onclick="resetTutorial()">Reset Tutorial</button>
            </div>
          </div>

          <div style="width:320px">
            <h3>How to think</h3>
            <div class="instructions">
              <p><strong>Switching:</strong> After each full turn (you + computer) your symbol flips. If you played O this turn, you'll play X next turn.</p>
              <p><strong>Strategy:</strong> Create 3-in-a-row threats and forks (two threats simultaneously). Always check for immediate opponent wins and block them first.</p>
              <p><strong>Modes:</strong> Easy = 7s, Medium = 3s, Hard = 3s + color chaos (visual changes).</p>
            </div>
            <h4>Start playing</h4>
            <div style="display:flex;gap:8px;flex-wrap:wrap;">
              <button onclick="go('easy')">Play Easy</button>
              <button onclick="go('medium')">Play Medium</button>
              <button onclick="go('hard')">Play Hard</button>
            </div>
          </div>
        </div>

        <div style="margin-top:12px">
          <h3>Assistant</h3>
          <div id="chat-home" class="chat"></div>
        </div>
      </section>

      <!-- MODE TEMPLATE: Easy -->
      <section id="easy" class="page panel" aria-hidden="true">
        <h2>Easy Mode</h2>
        <div class="instructions">You have <strong>7 seconds</strong> per turn. Static colors. Press <strong>Start</strong> to begin your first turn as <strong>O</strong>.</div>

        <div style="display:flex;gap:18px;align-items:flex-start">
          <div>
            <div id="board-easy" class="board" role="grid" aria-label="Easy board"></div>
          </div>

          <div class="status">
            <div>Timer: <span id="timer-easy" class="timer">7</span>s</div>
            <div id="current-easy" class="current-symbol">Your symbol: <strong id="symbol-easy">O</strong></div>
            <div class="controls">
              <button onclick="startGame('easy')">Start</button>
              <button onclick="resetGame('easy')">Reset</button>
              <button onclick="go('home')">Back</button>
            </div>
            <div id="message-easy" style="margin-top:10px;color:rgba(0,0,0,0.7)"></div>

            <div style="margin-top:12px">
              <h4>Assistant</h4>
              <div id="chat-easy" class="chat"></div>
            </div>
          </div>
        </div>
      </section>

      <!-- Medium -->
      <section id="medium" class="page panel" aria-hidden="true">
        <h2>Medium Mode</h2>
        <div class="instructions">You have <strong>3 seconds</strong> per turn. Static colors. AI uses minimax depth-limited planning.</div>

        <div style="display:flex;gap:18px;align-items:flex-start">
          <div>
            <div id="board-medium" class="board" role="grid" aria-label="Medium board"></div>
          </div>

          <div class="status">
            <div>Timer: <span id="timer-medium" class="timer">3</span>s</div>
            <div id="current-medium" class="current-symbol">Your symbol: <strong id="symbol-medium">O</strong></div>
            <div class="controls">
              <button onclick="startGame('medium')">Start</button>
              <button onclick="resetGame('medium')">Reset</button>
              <button onclick="go('home')">Back</button>
            </div>
            <div id="message-medium" style="margin-top:10px;color:rgba(0,0,0,0.7)"></div>

            <div style="margin-top:12px">
              <h4>Assistant</h4>
              <div id="chat-medium" class="chat"></div>
            </div>
          </div>
        </div>
      </section>

      <!-- Hard -->
      <section id="hard" class="page panel" aria-hidden="true">
        <h2>Hard Mode</h2>
        <div class="instructions">You have <strong>3 seconds</strong> per turn. Colors change every turn (visual chaos). AI planning same as medium.</div>

        <div style="display:flex;gap:18px;align-items:flex-start">
          <div>
            <div id="board-hard" class="board" role="grid" aria-label="Hard board"></div>
          </div>

          <div class="status">
            <div>Timer: <span id="timer-hard" class="timer">3</span>s</div>
            <div id="current-hard" class="current-symbol">Your symbol: <strong id="symbol-hard">O</strong></div>
            <div class="controls">
              <button onclick="startGame('hard')">Start</button>
              <button onclick="resetGame('hard')">Reset</button>
              <button onclick="go('home')">Back</button>
            </div>
            <div id="message-hard" style="margin-top:10px;color:rgba(0,0,0,0.7)"></div>

            <div style="margin-top:12px">
              <h4>Assistant</h4>
              <div id="chat-hard" class="chat"></div>
            </div>
          </div>
        </div>
      </section>
    </main>

    <footer>Prototype — open this file in your browser. Code commented for symbol-switching, timing and AI logic.</footer>
  </div>

  <script>
  /*************************************************************************
   *  Single-file 5x5 Tic-Tac-Toe
   *
   * Features implemented:
   * - 5x5 board, win = 4 in a row (hor/vert/diag)
   * - Player starts as O. After player+computer moves, player's symbol flips (O <-> X).
   * - Start button required to begin; timer begins only after Start pressed.
   * - Timer per mode (Easy 7s, Medium 3s, Hard 3s). If timer reaches 0 on player's turn -> immediate loss.
   * - AI: checks immediate wins, blocks immediate opponent wins, otherwise uses minimax with alpha-beta (depth-limited)
   * - Hard mode: colors change every completed turn for visual chaos.
   * - Tutorial (home): interactive; explains each click, announces winner, asks user to reset if a win occurs.
   * - Last-game recording per mode: when a game finishes and the user clicks Reset, the finished game (moves + result)
   *   is stored. Chat assistant can explain the last recorded game for that mode.
   *
   * Important state objects and their responsibilities are documented in comments.
   *************************************************************************/

  // ---------------------
  // Utilities
  // ---------------------
  function opposite(sym){ return sym === 'X' ? 'O' : 'X'; }
  function go(pageId){
    document.querySelectorAll('.page').forEach(p=>p.classList.remove('active'));
    const el = document.getElementById(pageId);
    if(el) el.classList.add('active');
    // update current page context
    currentPage = pageId;
  }

  // ---------------------
  // Configuration
  // ---------------------
  const MODES = {
    easy:   { time:7,  boardId:'board-easy', timerId:'timer-easy', symbolId:'symbol-easy', messageId:'message-easy', chaos:false, minimaxDepth:3 },
    medium: { time:3,  boardId:'board-medium', timerId:'timer-medium', symbolId:'symbol-medium', messageId:'message-medium', chaos:false, minimaxDepth:4 },
    hard:   { time:3,  boardId:'board-hard', timerId:'timer-hard', symbolId:'symbol-hard', messageId:'message-hard', chaos:true,  minimaxDepth:4 }
  };

  // ---------------------
  // Per-mode game state
  // ---------------------
  // games[mode] = {
  //   grid: Array(25) of null | 'X' | 'O',
  //   playerSymbol: 'O' or 'X' (what the human will place next),
  //   running: boolean (timer running),
  //   intervalId: number | null,
  //   started: boolean (Start pressed),
  //   moves: array of strings (history: "Player O -> idx", "Computer X -> idx")
  //   lastResult: string or null (e.g. "Player (O) wins")
  // }
  const games = { easy:null, medium:null, hard:null };

  // lastRecorded[mode] stores the last recorded finished game for the chatbot to use.
  // This is only updated when a game has ended AND the user clicks Reset afterward (as requested).
  const lastRecorded = { easy:null, medium:null, hard:null };

  let currentPage = 'home'; // current visible page id (home / easy / medium / hard)

  // ---------------------
  // Initialization on load
  // ---------------------
  window.addEventListener('load', ()=>{
    // build boards and tutorial & chat widgets
    for(const m of Object.keys(MODES)) buildBoard(m);
    buildTutorial();
    createChatWidget('chat-home', 'home');
    createChatWidget('chat-easy', 'easy');
    createChatWidget('chat-medium','medium');
    createChatWidget('chat-hard','hard');
  });

  // ---------------------
  // Board creation & reset
  // ---------------------
  function buildBoard(mode){
    const cfg = MODES[mode];
    const container = document.getElementById(cfg.boardId);
    container.innerHTML = '';
    for(let idx=0; idx<25; idx++){
      const cell = document.createElement('div');
      cell.className = 'cell';
      cell.dataset.index = idx;
      cell.addEventListener('click', ()=>onPlayerClick(mode, idx));
      container.appendChild(cell);
    }
    // initialize game object (not started until Start pressed)
    games[mode] = createNewGame(mode);
    renderFullBoard(mode);
  }

  function createNewGame(mode){
    return {
      grid: Array(25).fill(null),
      playerSymbol: 'O', // Human starts as O by requirement
      running: false,
      intervalId: null,
      started: false,
      moves: [],
      lastResult: null
    };
  }

  // When Start is pressed, reset board and begin first player's turn
  function startGame(mode){
    const cfg = MODES[mode];
    games[mode] = createNewGame(mode);
    games[mode].started = true;
    document.getElementById(cfg.messageId).textContent = '';
    renderFullBoard(mode);
    if(cfg.chaos) applyRandomColors(); // apply initial chaotic colors for Hard
    startTurn(mode); // player's turn begins
  }

  // Reset button: if a game had finished and lastResult exists, record that finished game,
  // then create a fresh unstarted state.
  function resetGame(mode){
    const g = games[mode];
    // save a copy of finished game only if it had a lastResult (someone won or draw) and moves > 0
    if(g && g.lastResult && g.moves && g.moves.length>0){
      // store minimal recording: moves array and lastResult and timestamp
      lastRecorded[mode] = {
        moves: g.moves.slice(),
        result: g.lastResult,
        when: new Date().toISOString()
      };
    }
    // clear interval
    if(g && g.intervalId) clearInterval(g.intervalId);
    // reset state (unstarted)
    games[mode] = createNewGame(mode);
    renderFullBoard(mode);
    document.getElementById(MODES[mode].timerId).textContent = MODES[mode].time;
    document.getElementById(MODES[mode].symbolId).textContent = games[mode].playerSymbol;
    document.getElementById(MODES[mode].messageId).textContent = 'Game reset. Press Start to begin.';
  }

  // ---------------------
  // Turn & timing logic
  // ---------------------
  function startTurn(mode){
    const cfg = MODES[mode];
    const g = games[mode];
    if(!g || !g.started) return; // don't start unless Start was pressed

    // reset timer display
    g.timer = cfg.time;
    document.getElementById(cfg.timerId).textContent = g.timer;
    document.getElementById(cfg.symbolId).textContent = g.playerSymbol;
    if(g.intervalId) clearInterval(g.intervalId);
    g.running = true;
    g.intervalId = setInterval(()=>{
      g.timer -= 1;
      document.getElementById(cfg.timerId).textContent = g.timer;
      if(g.timer <= 0){
        clearInterval(g.intervalId);
        g.running = false;
        // Timeout behaviour: player loses immediately
        const compSym = opposite(g.playerSymbol);
        g.lastResult = `Computer (${compSym}) wins by timeout.`;
        endGame(mode, `Time's up — computer (${compSym}) wins.`);
      }
    }, 1000);
  }

  // Player clicks to place their symbol
  function onPlayerClick(mode, idx){
    const g = games[mode];
    const cfg = MODES[mode];
    if(!g || !g.started) return; // must press Start
    if(!g.running) return;        // timer must be running (player turn)
    if(g.grid[idx]) return;       // occupied

    // Place player's symbol
    g.grid[idx] = g.playerSymbol;
    g.moves.push(`Player (${g.playerSymbol}) -> ${idx}`);
    renderCell(mode, idx);

    // stop player's timer because they've moved
    if(g.intervalId) clearInterval(g.intervalId);
    g.running = false;

    // Check for player win
    if(checkWin(g.grid, g.playerSymbol)){
      g.lastResult = `Player (${g.playerSymbol}) wins`;
      endGame(mode, `You (${g.playerSymbol}) win!`);
      return;
    }

    // Computer replies after short delay
    setTimeout(()=>computerMove(mode), 350);
  }

  // If the player times out, endGame already set result in startTurn.
  function handleTimeoutLoss(mode){
    // Not used as separate function in current code; left for clarity.
  }

  // ---------------------
  // Computer / AI
  // ---------------------
  function computerMove(mode){
    const g = games[mode];
    const cfg = MODES[mode];
    if(!g || !g.started) return;
    const compSym = opposite(g.playerSymbol);

    // 1) immediate win
    const winMove = findImmediateWin(g.grid, compSym);
    if(winMove != null){
      placeComputerMove(mode, winMove, compSym);
      return;
    }

    // 2) block opponent immediate win
    const blockMove = findImmediateWin(g.grid, g.playerSymbol);
    if(blockMove != null){
      placeComputerMove(mode, blockMove, compSym);
      return;
    }

    // 3) minimax with alpha-beta and heuristics (depth depends on mode)
    const depth = cfg.minimaxDepth;
    const {move: best} = minimaxDecision(g.grid.slice(), compSym, g.playerSymbol, depth);
    const chosen = (best != null) ? best : randomEmpty(g.grid);
    if(chosen == null){
      g.lastResult = 'Draw';
      endGame(mode, "It's a draw — board full.");
      return;
    }
    placeComputerMove(mode, chosen, compSym);
  }

  function placeComputerMove(mode, idx, compSym){
    const g = games[mode];
    if(!g) return;
    g.grid[idx] = compSym;
    g.moves.push(`Computer (${compSym}) -> ${idx}`);
    renderCell(mode, idx);

    // check for computer win
    if(checkWin(g.grid, compSym)){
      g.lastResult = `Computer (${compSym}) wins`;
      endGame(mode, `Computer (${compSym}) wins.`);
      return;
    }

    // Flip the player's symbol for the next turn (this is the flip rule)
    g.playerSymbol = opposite(g.playerSymbol);

    // If hard mode, change colors each turn for visual chaos
    if(MODES[mode].chaos) applyRandomColors();

    // Start next player's turn
    startTurn(mode);
  }

  // ---------------------
  // Rendering helpers
  // ---------------------
  function renderCell(mode, idx){
    const cfg = MODES[mode];
    const board = document.getElementById(cfg.boardId);
    const cell = board.querySelector(`.cell[data-index='${idx}']`);
    if(!cell) return;
    cell.textContent = games[mode].grid[idx] || '';
    const val = games[mode].grid[idx];
    cell.style.color = val === 'X' ? 'var(--x-color)' : val === 'O' ? 'var(--o-color)' : '';
    if(val) cell.classList.add('disabled'); else cell.classList.remove('disabled');
  }

  function renderFullBoard(mode){
    const cfg = MODES[mode];
    const board = document.getElementById(cfg.boardId);
    if(!board) return;
    for(let i=0;i<25;i++){
      const cell = board.querySelector(`.cell[data-index='${i}']`);
      const val = games[mode] ? games[mode].grid[i] : null;
      if(cell) {
        cell.textContent = val || '';
        cell.style.color = val === 'X' ? 'var(--x-color)' : val === 'O' ? 'var(--o-color)' : '';
        if(val) cell.classList.add('disabled'); else cell.classList.remove('disabled');
      }
    }
    if(games[mode]) document.getElementById(MODES[mode].symbolId).textContent = games[mode].playerSymbol;
  }

  function endGame(mode, message){
    const cfg = MODES[mode];
    const g = games[mode];
    if(g && g.intervalId) clearInterval(g.intervalId);
    if(g) g.running = false;
    if(g) document.getElementById(cfg.messageId).textContent = message;
    // disable remaining clicks visually
    document.querySelectorAll(`#${cfg.boardId} .cell`).forEach(c=>c.classList.add('disabled'));
  }

  // ---------------------
  // Win detection (4 in a row)
  // ---------------------
  function checkWin(grid, sym){
    function at(r,c){ if(r<0||r>4||c<0||c>4) return null; return grid[r*5 + c]; }
    const dirs = [[0,1],[1,0],[1,1],[-1,1]];
    for(let r=0;r<5;r++){
      for(let c=0;c<5;c++){
        if(at(r,c) !== sym) continue;
        for(const [dr,dc] of dirs){
          let count = 1;
          for(let k=1;k<4;k++){
            if(at(r+dr*k, c+dc*k) === sym) count++; else break;
          }
          if(count >= 4) return true;
        }
      }
    }
    return false;
  }

  // ---------------------
  // AI helpers (immediate win / minimax with alpha-beta)
  // ---------------------
  function findImmediateWin(grid, sym){
    for(let i=0;i<grid.length;i++){
      if(grid[i]) continue;
      grid[i] = sym;
      if(checkWin(grid, sym)){ grid[i] = null; return i; }
      grid[i] = null;
    }
    return null;
  }

  function randomEmpty(grid){
    const empties = [];
    for(let i=0;i<grid.length;i++) if(!grid[i]) empties.push(i);
    if(empties.length===0) return null;
    return empties[Math.floor(Math.random()*empties.length)];
  }

  function minimaxDecision(grid, compSym, playerSym, depthLimit){
    // For performance, order center-ish moves first
    let bestVal = -Infinity;
    let bestMove = null;
    const empties = [];
    for(let i=0;i<grid.length;i++) if(!grid[i]) empties.push(i);
    empties.sort((a,b)=>Math.abs(12-a)-Math.abs(12-b));
    for(const m of empties){
      grid[m] = compSym;
      const val = minimax(grid, depthLimit-1, false, -Infinity, Infinity, compSym, playerSym);
      grid[m] = null;
      if(val > bestVal){ bestVal = val; bestMove = m; }
    }
    return {move: bestMove, value: bestVal};
  }

  function minimax(grid, depth, isMaximizing, alpha, beta, compSym, playerSym){
    // Terminal checks
    if(checkWin(grid, compSym)) return 100000 + depth;
    if(checkWin(grid, playerSym)) return -100000 - depth;
    let empties = [];
    for(let i=0;i<grid.length;i++) if(!grid[i]) empties.push(i);
    if(empties.length === 0) return 0;
    if(depth === 0) return evaluateGrid(grid, compSym, playerSym);

    if(isMaximizing){
      let maxEval = -Infinity;
      for(const m of empties){
        grid[m] = compSym;
        const evalV = minimax(grid, depth-1, false, alpha, beta, compSym, playerSym);
        grid[m] = null;
        if(evalV > maxEval) maxEval = evalV;
        alpha = Math.max(alpha, evalV);
        if(beta <= alpha) break;
      }
      return maxEval;
    } else {
      let minEval = Infinity;
      for(const m of empties){
        grid[m] = playerSym;
        const evalV = minimax(grid, depth-1, true, alpha, beta, compSym, playerSym);
        grid[m] = null;
        if(evalV < minEval) minEval = evalV;
        beta = Math.min(beta, evalV);
        if(beta <= alpha) break;
      }
      return minEval;
    }
  }

  // Heuristic evaluation: counts runs of length 1..3 (4 is immediate win handled earlier)
  function evaluateGrid(grid, compSym, playerSym){
    const scores = {1:1, 2:10, 3:150}; // weights (3 is powerful)
    function at(r,c){ if(r<0||r>4||c<0||c>4) return null; return grid[r*5+c]; }
    const dirs = [[0,1],[1,0],[1,1],[-1,1]];
    let total = 0;
    for(let r=0;r<5;r++){
      for(let c=0;c<5;c++){
        for(const [dr,dc] of dirs){
          let compCount = 0, playerCount = 0;
          for(let k=0;k<4;k++){
            const v = at(r+dr*k, c+dc*k);
            if(v===compSym) compCount++;
            else if(v===playerSym) playerCount++;
          }
          if(compCount>0 && playerCount===0) total += scores[Math.min(compCount,3)];
          if(playerCount>0 && compCount===0) total -= scores[Math.min(playerCount,3)] * 1.1; // slightly prioritize blocking
        }
      }
    }
    return total;
  }

  // ---------------------
  // Hard mode visual chaos
  // ---------------------
  function applyRandomColors(){
    const rand = ()=>Math.floor(40 + Math.random()*215);
    const xCol = `rgb(${rand()},${rand()},${rand()})`;
    const oCol = `rgb(${rand()},${rand()},${rand()})`;
    const bgCol = `rgb(${Math.floor((rand()+rand())/2)%255},${Math.floor((rand()+rand())/2)%255},${Math.floor((rand()+rand())/2)%255})`;
    document.documentElement.style.setProperty('--x-color', xCol);
    document.documentElement.style.setProperty('--o-color', oCol);
    document.documentElement.style.setProperty('--bg', bgCol);
    // re-render boards so color variables apply
    ['easy','medium','hard'].forEach(m=>renderFullBoard(m));
  }

  // ---------------------
  // Tutorial (home)
  // ---------------------
  let tutorialState = null;
  function buildTutorial(){
    tutorialState = { grid: Array(25).fill(null), player: 'O', moves: [], gameOver: false };
    const tb = document.getElementById('tutorial-board');
    tb.innerHTML = '';
    for(let i=0;i<25;i++){
      const cell = document.createElement('div');
      cell.className = 'cell';
      cell.dataset.index = i;
      cell.addEventListener('click', ()=>tutorialClick(i));
      tb.appendChild(cell);
    }
    document.getElementById('tutorial-explain').innerHTML = 'Click any empty cell to place <strong>O</strong>. Explanations will appear here after each click.';
  }

  function tutorialClick(idx){
    const s = tutorialState;
    const tb = document.getElementById('tutorial-board');
    // disable if game over
    if(s.gameOver) return;
    if(s.grid[idx]) return;
    // player move
    s.grid[idx] = s.player;
    s.moves.push(`Player (${s.player}) -> ${idx}`);
    tb.children[idx].textContent = s.player;
    tb.children[idx].style.color = s.player === 'X' ? 'var(--x-color)' : 'var(--o-color)';
    // computer response
    const comp = opposite(s.player);
    const block = findImmediateWin(s.grid, s.player);
    let compMove = null;
    if(block != null) compMove = block;
    else if(!s.grid[12]) compMove = 12; 
    else compMove = randomEmpty(s.grid);
    if(compMove != null){
      s.grid[compMove] = comp;
      s.moves.push(`Computer (${comp}) -> ${compMove}`);
      tb.children[compMove].textContent = comp;
      tb.children[compMove].style.color = comp === 'X' ? 'var(--x-color)' : 'var(--o-color)';
    }
    // Build explanation string
    let explain = `<strong>You placed ${s.player}</strong> at row ${Math.floor(idx/5)+1}, col ${(idx%5)+1}.`;
    if(compMove != null){
      explain += ` Computer responded with <strong>${comp}</strong> at row ${Math.floor(compMove/5)+1}, col ${(compMove%5)+1}.`;
    }
    // Check win
    if(checkWin(s.grid, s.player)){
      explain += `<br><br><strong>${s.player} wins!</strong> Tutorial finished — press Reset to try again.`;
      s.gameOver = true;  // disable further clicks
    } else if(checkWin(s.grid, comp)){
      explain += `<br><br><strong>${comp} (computer) wins!</strong> Tutorial finished — press Reset to try again.`;
      s.gameOver = true;  // disable further clicks
    } else {
      explain += `<br><br>Next turn you will play <strong>${opposite(s.player)}</strong> — the symbol flips after each full turn.`;
      explain += `<br><br><strong>Tip:</strong> look for moves that create multiple threats (forks). Think a move or two ahead.`;
    }
    document.getElementById('tutorial-explain').innerHTML = explain;
    // flip player for next click
    s.player = opposite(s.player);
  }

  function resetTutorial(){
    tutorialState = { grid: Array(25).fill(null), player: 'O', moves: [], gameOver: false };
    const tb = document.getElementById('tutorial-board');
    for(let i=0;i<25;i++){ tb.children[i].textContent = ''; tb.children[i].style.color = ''; }
    document.getElementById('tutorial-explain').innerHTML = 'Click any empty cell to place <strong>O</strong>.';
  }

  // ---------------------
  // Chat assistant (simple rule-based)
  // - If lastRecorded for the requested mode exists, the assistant can explain it.
  // - Supports keywords: switch/symbol, timeout, hint, last/record
  // ---------------------
  function createChatWidget(containerId, modeKey){
    const container = document.getElementById(containerId);
    if(!container) return;
    container.innerHTML = `
      <div class="chat-log" id="${containerId}-log"></div>
      <div class="chat-input">
        <input id="${containerId}-input" placeholder="Ask me: 'hint', 'how symbols switch', 'what happened in last game'..." />
        <button id="${containerId}-send">Send</button>
      </div>
    `;
    document.getElementById(`${containerId}-send`).addEventListener('click', ()=>{
      const input = document.getElementById(`${containerId}-input`);
      handleChat(modeKey, input.value.trim(), document.getElementById(`${containerId}-log`));
      input.value = '';
      input.focus();
    });
  }

  function appendChat(logEl, who, text){
    const d = document.createElement('div');
    d.style.marginBottom = '8px';
    d.innerHTML = `<strong>${who}:</strong> ${text}`;
    logEl.appendChild(d);
    logEl.scrollTop = logEl.scrollHeight;
  }

  function handleChat(modeKey, text, logEl){
    if(!text) return;
    appendChat(logEl, 'You', text);
    const t = text.toLowerCase();
    const active = modeKey === 'home' ? null : modeKey;
    const g = active ? games[active] : null;
    // Symbol switching explanation
    if(t.includes('switch') || t.includes('symbol')){
      appendChat(logEl, 'Assistant', 'Symbols flip after each full turn (player + computer). You start as O. After both have played, you will place X next turn. This alternates every turn.');
      return;
    }
    // Timeout explanation
    if(t.includes('time') || t.includes('timeout') || t.includes('forfeit')){
      appendChat(logEl, 'Assistant', 'If your timer runs out during your turn, you forfeit and the computer wins immediately.');
      return;
    }
    // Strategy / mistake analysis
    if(t.includes('wrong') || t.includes('mistake')){
      if(!g || !g.started){
        appendChat(logEl, 'Assistant', 'Start a game first so I can analyze your moves.');
        return;
      }
      const lastMove = g.moves[g.moves.length-1];
      if(!lastMove){
        appendChat(logEl, 'Assistant', 'You haven\'t made any moves yet.');
      } else {
        appendChat(logEl, 'Assistant', `Last move: ${lastMove}. Tip: try to create multiple threats (forks) and block immediate wins. Avoid isolated moves that do not contribute to 3-in-a-row.`);
      }
      return;
    }
    // Hint
    if(t.includes('hint') || t.includes('suggest')){
      if(!g || !g.started){
        appendChat(logEl, 'Assistant', 'Start a game first to get a hint.');
        return;
      }
      const compSym = opposite(g.playerSymbol);
      const {move} = minimaxDecision(g.grid.slice(), g.playerSymbol, compSym, 3);
      const chosen = (move != null) ? move : randomEmpty(g.grid);
      if(chosen == null){
        appendChat(logEl, 'Assistant', 'No moves available (board full or draw).');
        return;
      }
      const r = Math.floor(chosen/5)+1, c = (chosen%5)+1;
      appendChat(logEl, 'Assistant', `Suggested move: row ${r}, column ${c}. Highlighted on board.`);
      const cfg = MODES[active];
      const cell = document.querySelector(`#${cfg.boardId} .cell[data-index='${chosen}']`);
      if(cell){ cell.classList.add('hint'); setTimeout(()=>cell.classList.remove('hint'), 1700); }
      return;
    }
    // Last recorded game
    if(t.includes('last') || t.includes('record')){
      if(!active){ 
        appendChat(logEl, 'Assistant', 'Go to a mode page (Easy/Medium/Hard) and ask for "last" there.'); 
        return; 
      }
      const rec = lastRecorded[active];
      if(!rec){
        appendChat(logEl, 'Assistant', `No recorded last game for ${active}.`);
        return;
      }
      const snippet = rec.moves.slice(0,12).join(' → ');
      appendChat(logEl, 'Assistant', `Last recorded game (${active}): ${rec.result}. Moves: ${snippet}${rec.moves.length>12? ' → ...':''}.`);
      return;
    }
    // Default
    appendChat(logEl, 'Assistant', 'I can explain symbol switching, timeouts, give hints, analyze mistakes, or summarize the last recorded game.');
  }

  // ---------------------
  // last-record behavior note:
  // - We persist the last game only in-memory (lastRecorded object).
  // - It is written when Reset is clicked and the previous game had a lastResult.
  // - The user is not shown internal recording mechanics — assistant only uses this to describe the last game on request.
  // ---------------------

  // ---------------------
  // Utility: populate DOM boards initially (empty)
  // ---------------------
  (function initEmptyBoards(){
    for(const m of Object.keys(MODES)){
      const cfg = MODES[m];
      const board = document.getElementById(cfg.boardId);
      if(!board) continue;
      // ensure cells exist and index attribute set (in case of reload)
      board.innerHTML = '';
      for(let i=0;i<25;i++){
        const cell = document.createElement('div');
        cell.className = 'cell';
        cell.dataset.index = i;
        cell.addEventListener('click', ()=>onPlayerClick(m, i));
        board.appendChild(cell);
      }
      // initialize per-mode state object
      games[m] = createNewGame(m);
      document.getElementById(cfg.timerId).textContent = cfg.time;
      document.getElementById(cfg.symbolId).textContent = games[m].playerSymbol;
    }
  })();

  // ---------------------
  // End of script
  // ---------------------
  </script>
</body>
</html>
